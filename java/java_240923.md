## ch12. 람다식
### `람다식이란? 람다식 작성하기`
람다식은 함수(메서드)를 간단한 식으로 표현하는 방법으로 익명함수를 생성하기 위한 식이라고도 할 수 있다.

- 코드가 매우 간결해진다.
- 컬렌션 요소를 필터링 하거나 매핑해서 원하는 결과를 쉽게 집계할 수 있다.

<br>

< Before >
```java
int max(int v1, int v2) {
		return v1 > v2 ? v1 : v2;
}
```

< After >
```java
(v1, v2) -> v1 > v2 ? v1 : v2
```
람다식은 `(매개변수) → {실행코드}` 형태로 작성되는데, 마치 함수 정의 형태를 띠고 있지만 런타임 시점에 인터페이스의 `익명 구현 객체`로 생성된다.

<br>

### `기본 문법`
람다식을 작성하는 방법은 다음과 같다.

```jsx
(타입 매개변수, ...) -> { 실행문; ...; }
```

만약 매개 변수가 없다면 람다식에서 매개 변수 자리가 없어지므로 다음과 같이 빈 괄호( )를 반드시 사용해야 한다.

```jsx
() -> { 실행문 .. }
```

<br>

### `함수형 인터페이스`
#### 1. 함수형 인터페이스 (@FunctionalInterface) 
함수형 인터페이스는 단 하나의 추상 메소드만 선언된 인터페이스를 말한다.


```java
@FunctionalInterface
public interface MyFuntionalInterface {
    public void method();
    public void method2();    // 컴파일 오류 발생
}
```
@FunctionalInterface 어노테이션은 선택사항이다. 이 어노테이션이 없더라도 하나의 추상 메소드만 있다면 모두 함수형 인터페이스이다. 그러나 위의 예시와 같이, 실수로 두 개 이상의 추상 메소드를 선언하는 것을 방지하고 싶다면 붙여주는 것이 좋다.

<br>

#### 2. 매개 변수와 리턴값이 없는 람다식
다음과 같이 매개 변수와 리턴값이 없는 추상 메소드를 가진 함수형 인터페이스가 있다고 가정해보면

```java
@FunctionalInterface
public interface MyFunctionalInterface {
    void method();
}
```

이 인터페이스를 타겟 타입으로 갖는 람다식은 다음과 같은 형태로 작성해야 한다.

```java
MyFunctionalInterface finter = () -> { ... }
```

<br>

#### 3. 매개 변수가 있는 람다식
다음과 같이 매개 변수가 있고 리턴값이 없는 추상 메소드를 가진 함수형 인터페이스가 있다고 해보면

```java
@FunctionalInterface
public interface MyFunctionalInterface2 {
    void method(int x);
}
```

이 인터페이스를 타켓 타입으로 갖는 람다식은 다음과 같은 형태로 작성해야 한다. 람다식에서 매개변수가 한 개인 이유는 method()가 매개 변수를 하나만 가지기 때문이다.

```java
MyFunctionalInterface finter = (x) -> { ... };
```
-> 매개변수 1개이면 ( ) 생략 가능

<br>

#### 4. 리턴값이 있는 람다식
이번에는 리턴값이 있는 람다식을 보면

```java
@FunctionalInterface
public interface MyFunctionalInterface3 {
    int method(int x, int y);
}
```

이 인터페이스를 타겟 타입으로 갖는 람다식은 다음과 같이 작성해야 한다. 메소드의 리턴 타입이 있기 때문에 중괄호 { } 에는 return문이 있어야 한다.

```java
MyFunctionalInterface fi = (x, y) -> { ...; return 값; }
```

<br>

#### 5. 함수형 인터페이스의 장점
함수형 인터페이스는 재사용 가능한 코드를 만들 수 있는 장점이 있고 간결하고 직관적인 코드를 작성할 수 있다.

<br>

### `java.util.function 패키지`

java.util.function 패키지는 자주 사용되는 다양한 함수형 인터페이스를 제공한다. 같은 매개변수 타입과 리턴타입의 람다식을 참조 가능하다.

![image](/image/lamda.png)

<br>

#### 1. Runnable

- 매개변수와 리턴 값 모두 없는 경우

```java
package java.lang;

@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```

아래 예시처럼 매개변수와 리턴값(타입)이 없는 람다식을 참조 가능

```java
Runnable r = () -> System.out.println("출력문 테스트");
r.run();    // "출력문 테스트" 
```

<br>

#### 2. Supplier<T>

- 매개변수는 없고, 리턴값(타입)이 있는 경우

```java
package java.util.function;

@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

아래 예시처럼 매개변수가 없고, 리턴타입이 있는 람다식을 참조 가능

```java
Supplier<String> s = **() -> "리턴되는 값";**
String result = s.get();
System.out.println(result);   // "리턴되는 값"
```

<br>

#### 3. Consumer<T>

- Supplier와 반대로, 매개변수는 있지만 리턴타입이 없다.
- 매개변수는 있지만 리턴타입이 없는 람다식을 참조 가능

```java
package java.util.function;

@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
```

```java
Consumer<String> c = (a) -> System.out.println(a);
c.accept("consumer");
```

<br>

#### 4. Function<T, R>

- 하나의 매개변수를 받아서 하나의 결과를 리턴한다.
- 매개변수를 받아서 하나의 결과를 리턴하는 람다식을 참조 가능

```java
package java.util.function;

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
```

```java
Function<Integer, String> f = a -> String.valueOf(a);
Function<String, Integer> f2 = b -> {
    return Integer.valueOf(b) + 100;
};
```

#### 5. Predicate<T>

- 조건식을 표현하는데 사용된다.
- 매개변수는 하나, 리턴타입은 boolean을 갖는 함수형 인터페이스

```java
package java.util.function;

@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```

<br>

### `메소드 참조`
말 그대로 메소드를 참조해서 매개 변수의 정보 및 리턴 타입을 알아내어, 람다식에서 불필요한 매개 변수를 제거하는 것이 목적이다.

<br>

#### 1. 정적 메소드 및 인스턴스 메소드 참조
정적(static) 메소드를 참조할 경우에는 클래스 이름 뒤에 :: 기호를 붙이고 정적 메소드 이름을 쓰면 된다.

```java
클래스::메소드 
```

인스턴스 메소드일 경우에는 먼저 객체를 생성한 다음, 참조 변수 뒤에 :: 기호를 붙이고 인스턴스 메소드 이름을 쓰면 된다.

```java
참조변수::메소드 
```

<br>

#### 2. 매개변수의 메소드 참조
다음과 같이 람다식에서 제공되는 a 매개변수의 메소드를 호출해서 b 매개변수를 매개값으로 사용하는 경우를 보면

```java
(a, b) -> { a.instanceMethod(b); }
```

이것을 메소드로 표현하면 a클래스 이름 뒤에 :: 기호를 붙이고, 메소드 이름을 기술하면 된다.

```java
클래스::instanceMethod
```

<br>

#### 3. 생성자 참조
메소드 참조(method references)는 생성자 참조도 포함한다. 생성자를 참조한다는 것은 객체를 생성하는 것을 의미한다. 단순히 메소드 호출로 구성된 람다식을 메소드 참조로 대치할 수 있듯이, 단순히 객체를 생성하고 리턴하는 람다식은 생성자 참조로 대치할 수 있다.

다음 코드를 보면 람다식은 단순히 객체 생성 후 리턴만 한다.

```java
(a, b) -> { return new 클래스(a, b); }
```

이 경우 생성자 참조로 표현하면 다음과 같다.

```java
클래스 :: new
```

<br>

## Daily Quiz
1. 